#!/usr/bin/env python3

##
# @file
# calculate surface mass density falloff of circular rings
# around center of mass calculate velocity dispersion of 2D rings from
# a Walker dataset calculate 4th order velocity moment (kurtosis) of
# 2D rings from a Walker dataset do this consistently with always the
# same sets of particles per bin

# (c) 2012-2014 ETHZ, Pascal S.P. Steger

import sys, pdb, math
import numpy as np
from scipy.stats import kurtosis
from pylab import *

import gr_params as gpr
from gl_file import empty, write_headers
from gl_helper import expDtofloat, bin_r_linear, bin_r_log, bin_r_const_tracers, add_errors
# from gl_class_files import *
from BiWeight import meanbiweight


def determine_radius(R, Rmin, Rmax, gp):
    if gp.lograd:
        print(gp.nipol, ' bins in log spacings')
        return bin_r_log(Rmax/gp.nipol, Rmax, gp.nipol)
    elif gp.consttr:
        print(len(R)/gp.nipol,' particles per bin')
        return bin_r_const_tracers(R, len(R)/gp.nipol)
    else:
        print(gp.nipol, ' bins in linear spacings')
        return bin_r_linear(Rmin, Rmax, gp.nipol)
## \fn determine_radius(R, Rmin, Rmax, gp)
# determine radius once and for all. this must not be changed between
# readout and gravlite run. if you wish to change: set gp.getnewdata =
# True in gl_params.py
# @param R
# @param Rmin float
# @param Rmax float
# @param gp global parameters


def volume_circular_ring(Binmin, Binmax, gp):
    Vol = np.zeros(gp.nipol)
    for k in range(gp.nipol):
        Vol[k] = np.pi*(Binmax[k]**2-Binmin[k]**2) # [Rscale^2]
    return Vol
## \fn volume_circular_ring(Binmin, Binmax, gp)
# volume of a circular ring from binmin to binmax
# @param Binmin
# @param Binmax
# @param gp global parameters


def set_bndry(R, gp):
    Rmin = 0. #[Rscale]
    if gp.maxR < 0:
        Rmax = max(R)
    else:
        Rmax = 1.0*gp.maxR # [Rscale]
    print('Rmax [Rscale] = ', Rmax)
    return Rmin, Rmax
## \fn set_bndry(R, gp)
# set number and size of (linearly spaced) bins
# @param R
# @param gp global parameters


def write_tracer_file(comp, totmass, gp):
    tr = open(gp.files.get_ntracer_file(comp), 'w')
    print(totmass, file=tr)
    tr.close()
## \fn write_tracer_file(comp, totmass, gp)
# write tracer file
# @param comp
# @param totmass
# @param gp global parameters
    

def read_Rscale(comp, gp):
    crscale = open(gp.files.get_scale_file(comp),'r')
    Rscale = np.loadtxt(crscale, comments='#', skiprows=1, unpack=False)
    crscale.close()
    return Rscale
## \fn read_Rscale(comp, gp)
# read scale radius from file
# @param comp int component 0,1,2
# @param gp global parameters


def write_density(comp, Dens0, Dens0pc, totmass, gp):
    cdens = open(gp.files.get_scale_file(comp),'a')
    print(Dens0, file=cdens)               # [munit/Rscale^2]
    print(Dens0pc, file=cdens)             # [munit/pc^2]
    print(totmass, file=cdens)             # [munit]
    cdens.close()
## \fn write_density(comp, Dens0, Dens0pc, totmass, gp)
# output density
# @param comp int component 0,1,2
# @param Dens0 central density [Msun/Rscale^2]
# @param Dens0pc central density [Msun/pc^2]
# @param totmass
# @param gp global parameters
    

def show_plots(comp, Rbin, P_dens, P_edens, p_dvlos, p_edvlos, p_kappa, p_ekappa, Dens0pc):
    # plot density
    ion(); subplot(111)
    plot(Rbin, P_dens*Dens0pc, 'b', lw=1)
    lbound = (P_dens-P_edens)*Dens0pc; lbound[lbound<1e-6] = 1e-6
    ubound = (P_dens+P_edens)*Dens0pc
    fill_between(Rbin, lbound, ubound, alpha=0.5, color='r')
    yscale('log')
    # xlim([0, gp.maxR]); ylim([np.min(lbound),np.max(ubound)])
    xlabel(r'$R [R_c]$')
    ylabel(r'$\nu_{2D}(R) [\mathrm{Msun/pc/pc}]$')
    savefig(gpr.get_dens_png(comp))
    ioff(); show(); clf()

    # plot siglos
    ion(); subplot(111)
    plot(Rbin, p_dvlos, 'b', lw=1)
    fill_between(Rbin, p_dvlos-p_edvlos, p_dvlos+p_edvlos, alpha=0.5, color='r')
    # [rscale],2*[km/s]

    xlabel(r'$R [\mathrm{Rscale}]$')
    ylabel(r'$\langle\sigma_{\mathrm{LOS}}\rangle [\mathrm{km/s}]$')
    ylim([-1, 30])
    # xlim([0, gp.maxR])
    savefig(gpr.get_siglos_png(comp))
    ioff(); show(); clf()


    # plot kappa
    ion(); subplot(111)
    print('Rbin = ', Rbin, ' Rscale')
    print('p_kappa = ', p_kappa)
    print('p_ekappa = ', p_ekappa)
    plot(Rbin, p_kappa, 'b', lw=1)
    fill_between(Rbin, p_kappa-p_ekappa, p_kappa+p_ekappa, alpha=0.5, color='r')
    # [rscale], 2*[1]
    xlabel(r'$R [\mathrm{Rscale}]$')
    ylabel(r'$\langle\kappa_{\mathrm{LOS}}\rangle [1]$')
    ylim([0, 5.])
    # xlim([0, gp.maxR])
    savefig(gpr.get_kurtosis_png(comp))
    ioff(); show(); clf()
## \fn show_plots(comp, Rbin, P_dens, P_edens, p_dvlos, p_edvlos, p_kappa, p_ekappa, Dens0pc)
# show graphical representation of data after MCMC
# @param comp
# @param Rbin
# @param P_dens
# @param P_edens
# @param p_dvlos
# @param p_edvlos
# @param p_kappa
# @param p_ekappa
# @param Dens0pc

    
def run(gp):
    xall,yall = np.loadtxt(gpr.get_com_file(0), skiprows=1, usecols=(0,1), unpack=True)
    # 2*[Rscale]
    
    # calculate 2D radius on the skyplane
    R = np.sqrt(xall**2+yall**2) # [Rscale]

    Rmin, Rmax = set_bndry(R, gp)
    R = R[(R<Rmax)]

    Binmin, Binmax, Rbin = determine_radius(R, Rmin, Rmax, gp)
    Vol = volume_circular_ring(Binmin, Binmax, gp)

    for comp in range(gpr.ncomp):
        if empty(gpr.get_com_file(comp)): continue
        print('####### working on component ',comp)

        # start from data centered on COM already:
        print('input: ', gpr.get_com_file(comp))
        x,y,v = np.loadtxt(gpr.get_com_file(comp),\
                           skiprows=1,usecols=(0,1,2),unpack=True) #[rscale], [rscale], [km/s]

        R = np.sqrt(x**2+y**2) #[rscale]
        
        # set maximum radius (if gp.maxR is set)
        Rmin, Rmax = set_bndry(R, gp)
        sel = (R<=Rmax)
        x = x[sel]; y = y[sel]; v = v[sel]; R = R[sel] # [Rscale]
        totmass = float(len(x)) # [munit], munit = 1/star
        Rs = R                  #+possible starting offset, [Rscale]
        vlos = v                #+possible starting offset, [km/s]

        write_tracer_file(comp, totmass, gp)
        de, em, sigfil, kappafil = write_headers(gp, comp)

        # tracers per bin, shared by density, siglos, kappa
        # calculations
        tpb     = np.zeros((gp.nipol,gpr.n))
        Density = np.zeros((gp.nipol,gpr.n))
        sigma   = np.zeros((gp.nipol,gpr.n))
        kappa   = np.zeros((gp.nipol,gpr.n))


        # gpr.n=30 iterations for getting randomly picked radius and
        # v_LOS values
        # this gives us a handle on the stochastic error, which has a gaussian / normal distribution
        for k in range(gpr.n):
            Rsi   = add_errors(Rs,   gpr.Rerror) # [Rscale]
            vlosi = add_errors(vlos, gpr.vrerror) # [km/s]
            for i in range(gp.nipol):
                sel = np.argwhere(np.logical_and(Rsi >= Binmin[i],Rsi<Binmax[i])).flatten() # [1]
                lsel = float(len(sel))
                tpb[i][k] = lsel
                Density[i][k] = lsel*totmass/Vol[i] # [munit/rscale**2]

                if(lsel<=1): # missing values => use last value
                    sigma[i][k] = sigma[i-1][k]
                    kappa[i][k] = kappa[i-1][k]
                else:
                    sigma[i][k] = meanbiweight(vlosi[sel], ci_perc=68.4, ci_mean=True, ci_std=True)[1]
                                        # [km/s], see BiWeight.py
                    kappa[i][k] = kurtosis(vlosi[sel], axis=0, fisher=False, bias=False) # [1]


        # central density averaged over gpr.n iterations
        Dens0 = np.sum(Density[0])/float(gpr.n) # [munit/Rscale^2]
        Rscale = read_Rscale(comp, gp)
        Dens0pc = Dens0/Rscale**2              # [munis/pc^2]
        write_density(comp, Dens0, Dens0pc, totmass, gp)

        # number of tracers in central bin, it. averaged
        tpb0   = np.sum(tpb[0])/float(gpr.n)     # [1]

        # error on the central density (error of the mean)
        Denserr0 = Dens0/np.sqrt(tpb0)       # [munit/Rscale^2]
        P_dens  = np.zeros(gp.nipol);  P_edens = np.zeros(gp.nipol)
        for b in range(gp.nipol):
            Dens = np.sum(Density[b])/float(gpr.n) # [munit/Rscale^2]
            tpbb   = np.sum(tpb[b])/float(gpr.n)       # [1]
            Denserr = Dens/np.sqrt(tpbb)       # [munit/Rscale^2]

            # addition of gaussian errors from central density error and error on any given bin
            # only needed if we scale Sigma(R) s.t. Sigma(R=0) = 1
            # Denserror = np.sqrt( Denserr**2+(Dens*Denserr0)**2 )/Dens0 # [1]
            pdb.set_trace()
            
            if(math.isnan(Denserror)):
                Denserror = 0. # [1]
                P_dens[b] = P_dens[b-1]  # [1]
                P_edens[b]= P_edens[b-1] # [1]
            else:
                P_dens[b] = Dens/Dens0   # [1]
                P_edens[b]= Denserror    # [1]

            print(Rbin[b], Binmin[b], Binmax[b], P_dens[b], P_edens[b], file=de)
            # 3*[rscale], [dens0], [dens0]
            indr = (R<Binmax[b])
            Menclosed = 1.0*np.sum(indr)/totmass # for normalization
                                                 # to 1 #[totmass]
            Merror = Menclosed/np.sqrt(ab) # or artificial
                                           # Menclosed/10 #[totmass]
            print(Rbin[b], Binmin[b], Binmax[b], Menclosed, Merror, file=em)
            # [Rscale], 2* [totmass]
        de.close()
        em.close()

        # output siglos
        p_dvlos = np.zeros(gp.nipol);        p_edvlos = np.zeros(gp.nipol)
        for b in range(gp.nipol):
            dispvel = np.sum(sigma[b])/gpr.n #[km/s]
            tpbb = np.sum(tpb[b])/(float(gpr.n)) #[1]
            if tpbb == 0:
                dispvelerror = p_edvlos[b-1] #[km/s] attention! uses
                # last error
            else:
                dispvelerror = dispvel/np.sqrt(tpbb) #[km/s]
            p_dvlos[b] = dispvel      #[km/s]
            p_edvlos[b]= dispvelerror #[km/s]

        maxvlos = max(p_dvlos) #[km/s]
        print('maxvlos = ', maxvlos, '[km/s]')
        fpars = open(gp.files.get_scale_file(comp),'a')
        print(maxvlos, file=fpars)          #[km/s]
        fpars.close()
        
        for b in range(gp.nipol):
            print(Rbin[b], Binmin[b], Binmax[b], \
                  np.abs(p_dvlos[b]/maxvlos),np.abs(p_edvlos[b]/maxvlos), \
                  file=sigfil)
            # 3*[rscale], 2*[maxvlos]
        sigfil.close()


        # output kurtosis kappa
        p_kappa = np.zeros(gp.nipol) # needed for plotting later
        p_ekappa = np.zeros(gp.nipol)
        for b in range(gp.nipol):
            kappavel = np.sum(kappa[b])/gpr.n #[1]
            tpbb = np.sum(tpb[b])/float(gpr.n) #[1]
            if tpbb == 0:
                kappavelerror = p_edvlos[b-1] #[1] attention! uses
                # last error
            else:
                kappavelerror = np.abs(kappavel/np.sqrt(tpbb)) #[1]
            p_kappa[b] = kappavel
            p_ekappa[b] = kappavelerror
            
            print(Rbin[b], Binmin[b], Binmax[b],\
                  kappavel, kappavelerror, \
                  file=kappafil)
            # [rscale], 2*[1]
        kappafil.close()
    
        if gpr.showplots:
            show_plots(comp, Rbin, P_dens, P_edens, p_dvlos, p_edvlos, p_kappa, p_ekappa, Dens0pc)
## \fn run(gp)
# main functionality
# @param gp global parameters
            

if __name__ == '__main__':
    gpr.showplots = True
    import gl_params
    gp = gl_params.Params()
    run(gp)

