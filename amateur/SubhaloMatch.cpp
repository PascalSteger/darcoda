/**************************************************************************
 *   Copyright (C) 2010 by Pascal Stephan Philipp Steger                   *
 *   psteger@phys.ethz.ch                                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, ma  02111-1307, USA.             *
 ***************************************************************************/

/*!
 * \file SubhaloMatch.cpp
 * \brief This file provides a wrapper to convert mtree_idx files generated by an autocorrelation run of AMIGA to give the host halo.
 */

#include <string>
#include <iostream>
#include <map>
#include <fstream>
#include "Global.h"

void GetMtreeFile(std::string filename, int dim, unsigned * hostno, unsigned * hostpop, unsigned * sharedpop, unsigned * subno, unsigned * subpop){
  writedebug(DEBUG," * Reading mtree file...");
  std::ifstream infile(filename.c_str());
  for(int line=0; line<dim; ++line){
    infile >> hostno[line];
    infile >> hostpop[line];
    infile >> sharedpop[line];
    infile >> subno[line];
    infile >> subpop[line];
  }
  infile.close();
  donedebug(DEBUG);
}

void WriteMtree2File(std::string filename, int dim, unsigned * hostno, unsigned * hostpop, unsigned * sharedpop, unsigned * subno, unsigned * subpop){
  writedebug(DEBUG," * Writing read information back to mtree2...");
  std::ofstream outfile((filename+"2").c_str());
  for(int line=0; line<dim; ++line){
    outfile << hostno[line] << " ";
    outfile << hostpop[line] << " ";
    outfile << sharedpop[line] << " ";
    outfile << subno[line] << " ";
    outfile << subpop[line];
    outfile << std::endl;
  }
  outfile.close();
  donedebug(DEBUG);
}

void SubhaloMatch(unsigned isnap){
  std::string filename = Folder("output") + Snaps(isnap) + "/ahf_out_mtree";
  unsigned dim=GetLineNumber(filename);
  std::cout<<filename << " has " << dim << " lines." << std::endl;
  unsigned hostno[dim], hostpop[dim], sharedpop[dim], subno[dim], subpop[dim];
  GetMtreeFile( filename, dim, &hostno[0], &hostpop[0], &sharedpop[0], &subno[0], &subpop[0] );
  WriteMtree2File( filename, dim, &hostno[0], &hostpop[0], &sharedpop[0], &subno[0], &subpop[0] );
  //for(int line=0; line<dim; ++line)
  //	std::cout<<subno[line]<<std::endl;

  //std::cout<<" * Building hostno <=> sharedpop map...";
  //std::map<unsigned, unsigned> hsmap;
  //for ( unsigned j = 0; j < dim; ++j )
  //	hsmap.insert( std::make_pair ( hostno[ j ], sharedpop[ j ] ) );
  //std::endl<<"done!"<<std::endl;

  // find number of halos
  unsigned count=0;
  for(unsigned sh=0; sh<dim; ++sh)
    if( hostno[sh] == subno[sh] )
      ++count;
  std::cout << " * Found " << count << " different halos." << std::endl;
  int hosts[count];


  unsigned shcount = 0;
  unsigned sucount = 0;
  unsigned hocount = 0;
  // run through all subhalos
  for( unsigned subhalo = 0; subhalo < dim; ++subhalo ){
    if( hostno[subhalo] != subno[subhalo] )
      continue;
    std::cout << " * * Looking at line " << subhalo << std::endl;
    sucount = 0;
    hocount = 0;
    //count how many times it appears in subno
    std::cout << "subhalo = " << hostno[subhalo] << std::endl;
    for(unsigned su=0; su<dim; ++su)
      if( subno[su] == hostno[subhalo] )
	++sucount;
    //count how many times it appears in hostno
    for(unsigned ho=0; ho < dim; ++ho)
      if( hostno[ho] == hostno[subhalo] )
	++hocount;
    // autocorrelation should yield same no. subhalos and host halos
    std::cout << "sucount = " << sucount << ", hocount = " << hocount << std::endl;
    if(sucount!=hocount)
      std::cerr << " * * Found wrong subhalo!" << std::endl;
    if(sucount<2){
      std::cout << " * * Subhalo occurs only once, it has no host." << std::endl;
      hosts[shcount] = -1;
      ++shcount;
      continue;
    }

    std::cout<<" * * Generating array with shared populations...";
    unsigned shpop[sucount][2]; // [][0] takes sharepop, [][1] takes hostno
    unsigned shpopcount=0;
    for( unsigned sc = 0; sc < dim; ++sc){
      if(subno[sc] == hostno[subhalo] && subpop[sc]<hostpop[sc]){ // found occurrence
	shpop[shpopcount][0] = sharedpop[sc];
	shpop[shpopcount][1] = hostno[sc];
	std::cout << shpop[shpopcount][1] << " " << shpop[shpopcount][0] << std::endl;
	++shpopcount;
      }
    }
    std::cout << shpopcount << " constituents, done!" << std::endl;
    if(shpopcount==0){
      hosts[shcount]=-2;
      ++shcount;
      continue;
    }
    std::cout<<" * * Getting maximum of shared populations...";
    unsigned scmax=0;
    for(unsigned sc=0; sc<shpopcount; ++sc){
      if(shpop[sc][0]>shpop[scmax][0])
	scmax=sc;
    }
    std::cout<<scmax<<", done!"<<std::endl;
		
    std::cout<<" * * Getting host corresponding to maximal shared population... ";
    hosts[shcount]=shpop[scmax][1];
    ++shcount;
    std::cout<<hosts[shcount-1]<<", done!"<<std::endl;
  }
  std::cout << shcount << " subhalos matched."<<std::endl;

  writedebug(DEBUG," * Creating _mtree_idx file...");
  std::ofstream fout;
  fout.open ( (filename+"_idx2").c_str(), std::ios_base::out );
  for(unsigned sc=0; sc<shcount; ++sc){
    fout << sc << " "<<hosts[sc] << std::endl;
  }
  fout.close();
  donedebug(DEBUG);
}
